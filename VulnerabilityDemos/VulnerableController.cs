using Microsoft.AspNetCore.Mvc;
using SafeVault.Services;
using System.Data;
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;

namespace SafeVault.VulnerabilityDemos
{
    /// <summary>
    /// INTENTIONALLY VULNERABLE CONTROLLER FOR ACTIVITY 3 DEMONSTRATION
    /// This controller contains common security vulnerabilities for educational purposes
    /// DO NOT USE IN PRODUCTION
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class VulnerableController : ControllerBase
    {
        private readonly SafeVaultDbContext _context;
        private readonly ILogger<VulnerableController> _logger;

        public VulnerableController(SafeVaultDbContext context, ILogger<VulnerableController> logger)
        {
            _context = context;
            _logger = logger;
        }

        /// <summary>
        /// VULNERABILITY 1: SQL Injection - String concatenation in query
        /// This method is intentionally vulnerable to demonstrate SQL injection
        /// </summary>
        [HttpGet("vulnerable-search/{searchTerm}")]
        public async Task<IActionResult> VulnerableUserSearch(string searchTerm)
        {
            try
            {
                // VULNERABLE: Direct string concatenation - SQL Injection risk
                var connectionString = _context.Database.GetConnectionString();
                using var connection = new SqliteConnection(connectionString);
                await connection.OpenAsync();

                // DANGER: This creates SQL injection vulnerability
                var sql = $"SELECT * FROM Users WHERE Username LIKE '%{searchTerm}%' OR Email LIKE '%{searchTerm}%'";
                
                using var command = new SqliteCommand(sql, connection);
                using var reader = await command.ExecuteReaderAsync();
                
                var users = new List<object>();
                while (await reader.ReadAsync())
                {
                    users.Add(new
                    {
                        Id = reader.GetInt32("Id"),
                        Username = reader.GetString("Username"),
                        Email = reader.GetString("Email")
                    });
                }

                return Ok(users);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in vulnerable search");
                
                // VULNERABILITY 2: Information disclosure in error messages
                return BadRequest($"Database error: {ex.Message}");
            }
        }

        /// <summary>
        /// VULNERABILITY 3: XSS - Unencoded output
        /// This method returns user input without proper encoding
        /// </summary>
        [HttpPost("vulnerable-echo")]
        public IActionResult VulnerableEcho([FromBody] EchoRequest request)
        {
            // VULNERABLE: No input validation or output encoding
            var response = $"<div>You said: {request.Message}</div>";
            
            return Content(response, "text/html");
        }

        /// <summary>
        /// VULNERABILITY 4: Path traversal
        /// This method is vulnerable to directory traversal attacks
        /// </summary>
        [HttpGet("vulnerable-file/{fileName}")]
        public async Task<IActionResult> VulnerableFileAccess(string fileName)
        {
            try
            {
                // VULNERABLE: No path validation - Directory traversal risk
                var filePath = Path.Combine("wwwroot", fileName);
                
                if (System.IO.File.Exists(filePath))
                {
                    var content = await System.IO.File.ReadAllTextAsync(filePath);
                    return Ok(new { fileName, content });
                }
                
                return NotFound();
            }
            catch (Exception ex)
            {
                return BadRequest($"Error accessing file: {ex.Message}");
            }
        }

        /// <summary>
        /// VULNERABILITY 5: Weak session management
        /// This method creates predictable session tokens
        /// </summary>
        [HttpPost("vulnerable-login")]
        public IActionResult VulnerableLogin([FromBody] LoginRequest request)
        {
            // VULNERABLE: Weak token generation
            var timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
            var weakToken = $"token_{request.Username}_{timestamp}";
            
            // VULNERABLE: No secure token storage
            Response.Cookies.Append("auth_token", weakToken, new CookieOptions
            {
                HttpOnly = false, // VULNERABLE: Should be true
                Secure = false,   // VULNERABLE: Should be true in production
                SameSite = SameSiteMode.None // VULNERABLE: Should be Strict
            });

            return Ok(new { token = weakToken, message = "Login successful" });
        }
    }

    public class EchoRequest
    {
        public string Message { get; set; } = string.Empty;
    }

    public class LoginRequest
    {
        public string Username { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }
}
